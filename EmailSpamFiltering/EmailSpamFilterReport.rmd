---
title: "Email Spam Filtering"
output: html_notebook
---

## Step 1: Data Setup and Exploration

### Setup Knitr
```{r setup, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

### Get the appropriate libraries
```{r libraries}
library(tidyverse)
library(e1071)
library(mice)
library(Amelia)
library(scales)

getwd()
```

### Load the Data
```{r loadData}
# Get Data from ClassExamples Directory


spam <- read_csv(file='completeSpamAssassin.csv')
head(spam)
# NOTE: Change col_types variable appropriately
```

# Explore the model by getting a glimpse of the data.
```{r exploreModel}
glimpse(spam)
```


## Step 2: Preparing training and testing sets
```{r model}
# Set a seed to randomize model generation
set.seed(1234)

# Create a sample of the data
sample_set <- sample(c(1:dim(spam)[1]), dim(spam)[1]*0.75)

# Split training and testing set using 75:25 split
spam_train <- spam[sample_set,]
spam_test <- spam[-sample_set,]
```

## Step 3: Build the Bayesian Model (Naive)
```{r buildModel}
# Build the naive model based on training set
spam_mod <- naiveBayes(Label ~ ., data = spam_train, laplace = 1)
spam_mod
```

## Step 4: Improve the Bayesian Model
```{r improveModel}
# I don't know what to do here lol
```

## Step 5: Interpret the Model Output


## Step 6: Estimate Errors


## Step 7: Make predictions using the test set
```{r predict}
spam_pred <- predict(spam_mod, newdata = spam_test, type = "raw")
spam_pred
spam_pred <- predict(spam_mod, newdata = spam_test, type = "class")
spam_pred
```

## Step 8: Model Verification


## Step 9: Final Spam Identification Results

### Create confusion matrix of our results
```{r confusion}
# Print Confusion Matrix
spam_pred_table <- table(spam_test$Label, spam_pred)
spam_pred_table

# Accuracy
sum(diag(spam_pred_table)) / nrow(spam_test)
```


## References