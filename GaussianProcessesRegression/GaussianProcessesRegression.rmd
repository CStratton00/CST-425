---
title: "Gaussian Processes Regression"
author: "Andrew Esch, Evan Lee, and Collin Stratton"
date: "3-13-2022"
output: html_notebook
---

# Introduction
TK

## Gene Expression and Differential Expressions
Gene Expression is the biological process found in cells in which genetic information (coded in the set of bases A, G, T, and C) is decoded and utilized to form a set of genetic products. The types of products that the process of gene expression can produce includes amino acids and proteins. This process is essential foundation for the formation of all biological life, and the differences in gene expression between cells is an important area of biology for further study.

Differential expression is the observation of a statistically significant difference or change in read counts or expression levels. To find a differential expression between genes, it is important to use statistical models to find if there is statistically significant difference for these metrics.


## Control and Treatment Categorizations
A control is a group categorization that does not have any affected conditions. In other words, this group acts as the baseline for all other measurements in a model. The standard for most models is to feature one control. Alternatively, a treatment is a type of group categorization that has been affected by some type of condition. They are also known as experimental group categorizations. A model may feature several treatments.


```{r}
#RUN ONCE THEN COMMENT OUT
# if (!requireNamespace("BiocManager"))
   # install.packages("BiocManager")
# BiocManager::install(c("limma", "edgeR", "Glimma", "org.Mm.eg.db", "gplots", "RColorBrewer", "NMF", "BiasedUrn"))

library(edgeR)
# edgeRUserGuide()
library(limma)
library(Glimma)
library(org.Mm.eg.db)
library(gplots)
library(RColorBrewer)
library(NMF)
library(MASS)
library(plyr)
library(reshape2)
library(ggplot2)
library(GauPro)
library(kernlab)
set.seed(1234)

```

```{r Import Data}

#Evan Import -> C:/GCU Academics/Junior Year/Second Semester/CST-425/CLC Shared GitHub Repository/Cloned Repository/GaussianProcessesRegression/

#Andrew Import -> C:/Users/andre/Documents/GitHub/CST-425/GaussianProcessesRegression/

# Read the data into R
seqdata <- read.delim("C:/Users/andre/Documents/GitHub/CST-425/GaussianProcessesRegression/GSE60450_LactationGenewiseCounts.txt", stringsAsFactors = FALSE)
# Read the sample information into R
sampleinfo <- read.delim("C:/Users/andre/Documents/GitHub/CST-425/GaussianProcessesRegression/SampleInfo.txt", stringsAsFactors = TRUE)

head(seqdata)
dim(seqdata)

sampleinfo
```

```{r Format Data}
# Remove first two columns from seqdata
countdata <- seqdata[,-(1:2)]

# Look at the output
head(countdata)

colnames(countdata)
# using substr, you extract the characters starting at position 1 and stopping at position 7 of the colnames
colnames(countdata) <- substr(colnames(countdata),start=1,stop=7)
head(countdata)
```

```{r DGEList}
dglist <- DGEList(countdata)
# have a look at y
dglist
names(dglist)

group <- paste(sampleinfo$CellType,sampleinfo$Status,sep=".")
# Take a look
group <- factor(group)
group

dglist$samples$group <- group
dglist$samples
```

```{r Annotations}
columns(org.Mm.eg.db)
#ann <- select(org.Mm.eg.db,keys=rownames(dglist$counts),columns=c("ENTREZID","SYMBOL","GENENAME"))
#table(ann$ENTREZID==rownames(dglist$counts))
#dglist$genes <- ann
```

```{r Filtering Out Genes}
# Obtain CPMs
myCPM <- cpm(countdata)

# Have a look at the output
head(myCPM)

# Which values in myCPM are greater than 0.5?
thresh <- myCPM > 0.5

# This produces a logical matrix with TRUEs and FALSEs
head(thresh)

# Summary of how many TRUEs there are in each row
# There are 11433 genes that have TRUEs in all 12 samples.
table(rowSums(thresh))

# we would like to keep genes that have at least 2 TRUES in each row of thresh
keep <- rowSums(thresh) >= 2
summary(keep)

# Let's have a look and see whether our threshold of 0.5 does indeed correspond to a count of about 10-15
# We will look at the first sample
plot(myCPM[,1],countdata[,1])

# Let us limit the x and y-axis so we can actually look to see what is happening at the smaller counts
plot(myCPM[,1],countdata[,1],ylim=c(0,50),xlim=c(0,3))
# Add a vertical line at 0.5 CPM
abline(v=0.5)

dglist <- dglist[keep, keep.lib.sizes=FALSE]
```

```{r Quality Control}
dglist$samples$lib.size

# The names argument tells the barplot to use the sample names on the x-axis
# The las argument rotates the axis names

barplot(dglist$samples$lib.size/1e06, names=colnames(dglist), las=2, ann=FALSE, cex.names=0.75)
mtext(side = 1, text = "Samples", line = 4)
mtext(side = 2, text = "Library size (millions)", line = 3)
title("Barplot of library sizes")

# Get log2 counts per million
logcounts <- cpm(dglist,log=TRUE)
# Check distributions of samples using boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2)
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
```

```{r Normalize DGELIST}
logcounts <- cpm(dglist,log=TRUE)
# Apply normalisation to DGEList object
dglist <- calcNormFactors(dglist)
dglist$samples

```

```{r Graphing DGELSIT}
par(mfrow=c(1,2))

for(x in 1:12){
  plotMD(logcounts,column = x)
  abline(h=0,col="grey")
  plotMD(dglist,column = x)
  abline(h=0,col="grey")
}

```


```{r TrainGaussianProcesses}
# Step 1: Create the kernel for the GP model
#rbf <- rbfdot(sigma = 0.05) # Use standard rbfdot model and set statistical significance to 0.05
#rbf
#km <- kernelMatrix(rbf, myCPM[,1])

# Step 2: Compute the GP model
#gpk <- GauPro_kernel_model$new(matrix(myCPM[,1], ncol=1), dglist, kernel=km, parallel=FALSE)
#if (requireNamespace("MASS", quietly = TRUE)) {
#  plot(gpk)
#}

# gpm <- GauPro(logcounts, dglist, parallel=FALSE)


```


```{r covariance}
# Note: Define x somewhere
#cov(x, dglist)
```

```{r prior}
# Gaussian Process Prior

```


## Optimization Parameters
TK (Discuss here)

```{r Differential Expression}
# Specify a design matrix without an intercept term
design <- model.matrix(~ 0 + group)
colnames(design) <- levels(group)
design
```

```{r VoomTransform}
# Generate a Voom (Mean-variance trend) graph and EList using the normalized factors
par(mfrow=c(1,1))
vtransform <- voom(dglist,design,plot = TRUE) # Create a plot representing this data
vtransform # Summarize the generated EList object
names(vtransform)
```


```{r showVoomTransformComparison}
par(mfrow=c(1,2))
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2,main="Unnormalised logCPM")
## Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
boxplot(vtransform$E, xlab="", ylab="Log2 counts per million",las=2,main="Voom transformed logCPM")
## Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(vtransform$E),col="blue")
```


```{r testDifferentialExpression}
# Using the normalized voom transform, we can test for differential expressions using limma

# Step 1: Create a linear model to represent each gene in the data using lmFit
fitted <- lmFit(vtransform) # Estimate the means and variances of each group using a design matrix
names(fitted) # Check the names of the items. Many of these are related to statisitcal testing, but it is important to ensure that the

# Step 2: Check for differential expression between the pregnant and lactating groups in basal cells.
contrastsMatrix <- makeContrasts(B.PregVsLac=basal.pregnant - basal.lactate,levels=design)
contrastsMatrix
```
According to the contrast matrix, the lactate and pregnant are differentially expressed overall (when the two groups show -1 and 1, this means they have different classifications based on the genes that identify them).


```{r VerifyDEStatistics}
# Step 3: Show statistics and estimated parameters for the two groups
fittedContrast <- contrasts.fit(fitted, contrastsMatrix) # Fit the contrast matrix based on the fitted voom transform (using linear model)
fittedContrast <- eBayes(fittedContrast) # Perform empirical Bayes on the variances & find t-values for each gene associated
dim(fittedContrast) # Verify dimension of the variances and means of each group (from the linear model above)

# Step 4: Use limma to generate a summary of the number of DE genes for the contrasted groups
fitSummary <- decideTests(fittedContrast)
summary(fitSummary)
```


```{r showDifferentialExpressionResults}
# To show the differentially expressed genes, create a graph from the decideTests to highlight the statistically significant genes
par(mfrow=c(1,2))
plotMD(fittedContrast,coef=1,status=fitSummary[,"B.PregVsLac"], values = c(-1, 1), hl.col=c("blue","red"))

# To further show the results, the volcano plot allows us to highlight the top genes from the contrastTest.
volcanoplot(fittedContrast,coef=1,highlight=50,names=fittedContrast$genes$SYMBOL, main="B.PregVsLac") # Show the top 50 statistically significant DE genes

```


```{r noise}
# Noise-free observations and predictions with noisy observations
library(wvtool)
noiseTest <- noise.filter(vtransform$E, n=15804, method="median") # Reduce noise?
# plot(myCPM[,1],countdata[,1],ylim=c(0,50),xlim=c(0,3))
```

#-----------------------------------Testing area---------------------------
```{r TEST}
library(MASS)
gaussprocess <- function(from = 0, to = 1, K = function(s, t) {min(s, t)},
                         start = 0, m = 1000) {
  # Simulates a Gaussian process with a given kernel
  #
  # args:
  #   from: numeric for the starting location of the sequence
  #   to: numeric for the ending location of the sequence
  #   K: a function that corresponds to the kernel (covariance function) of
  #      the process; must give numeric outputs, and if this won't produce a
  #      positive semi-definite matrix, it could fail; default is a Wiener
  #      process
  #   start: numeric for the starting position of the process
  #   m: positive integer for the number of points in the process to simulate
  #
  # return:
  #   A data.frame with variables "t" for the time index and "xt" for the value
  #   of the process

  t <- seq(from = from, to = to, length.out = m)
  Sigma <- sapply(t, function(s1) {
    sapply(t, function(s2) {
      K(s1, s2)
    })
  })

  path <- mvrnorm(mu = rep(0, times = m), Sigma = Sigma)
  path <- path - path[1] + start  # Must always start at "start"

  return(data.frame("t" = t, "xt" = path))
}
```


```{r Gaus}

head(df)
for(x in 1:5){
  df <- as.data.frame(gaussprocess())
  plot(df)
}

#ggplot(df)

```


## References
https://combine-australia.github.io/RNAseq-R/06-rnaseq-day1.html
https://www.r-bloggers.com/2012/04/gaussian-process-regression-with-r/
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4827276/
https://cran.r-project.org/web/packages/GauPro/vignettes/GauPro.html
https://www.rdocumentation.org/packages/kernlab/versions/0.9-29/topics/kernelMatrix
https://www.rdocumentation.org/packages/wvtool/versions/1.0/topics/noise.filter
https://www.geeksforgeeks.org/covariance-and-correlation-in-r-programming/