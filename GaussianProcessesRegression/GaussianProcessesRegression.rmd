---
title: "Gaussian Processes Regression"
author: "Andrew Esch, Evan Lee, and Collin Stratton"
date: "2-27-2022"
output: html_notebook
---

# Introduction
TK

## Gene Expression and Differential Expressions
Gene Expression is the biological process found in cells in which genetic information (coded in the set of bases A, G, T, and C) is decoded and utilized to form a set of genetic products. The types of products that the process of gene expression can produce includes amino acids and proteins. This process is essential foundation for the formation of all biological life, and the differences in gene expression between cells is an important area of biology for further study.

Differential expression is the observation of a statistically significant difference or change in read counts or expression levels. To find a differential expression between genes, it is important to use statistical models to find if there is statistical significants for these metrics.


## Control and Treatment Categorizations
A control is a group categorization that does not have any affected conditions. In other words, this group acts as the baseline for all other measurements in a model. The standard for most models is to feature one control. Alternatively, a treatment is a type of group categorization that has been affected by some type of condition. They are also known as experimental group categorizations. A model may feature several treatments.


```{r}
#RUN ONCE THEN COMMENT OUT
# if (!requireNamespace("BiocManager"))
#    install.packages("BiocManager")
# BiocManager::install(c("limma", "edgeR", "Glimma", "org.Mm.eg.db", "gplots", "RColorBrewer", "NMF", "BiasedUrn"))

library(edgeR)
# edgeRUserGuide()
library(limma)
library(Glimma)
library(org.Mm.eg.db)
library(gplots)
library(RColorBrewer)
library(NMF)
library(MASS)
library(plyr)
library(reshape2)
library(ggplot2)
library(GauPro)
set.seed(1234)

```

```{r Import Data}

#Evan Import -> C:/GCU Academics/Junior Year/Second Semester/CST-425/CLC Shared GitHub Repository/Cloned Repository/GaussianProcessesRegression/

#Andrew Import ->

# Read the data into R
seqdata <- read.delim("C:/GCU Academics/Junior Year/Second Semester/CST-425/CLC Shared GitHub Repository/Cloned Repository/GaussianProcessesRegression/GSE60450_LactationGenewiseCounts.txt", stringsAsFactors = FALSE)
# Read the sample information into R
sampleinfo <- read.delim("C:/GCU Academics/Junior Year/Second Semester/CST-425/CLC Shared GitHub Repository/Cloned Repository/GaussianProcessesRegression/SampleInfo.txt", stringsAsFactors = TRUE)

head(seqdata)
dim(seqdata)

sampleinfo
```

```{r Format Data}
# Remove first two columns from seqdata
countdata <- seqdata[,-(1:2)]

# Look at the output
head(countdata)

colnames(countdata)
# using substr, you extract the characters starting at position 1 and stopping at position 7 of the colnames
colnames(countdata) <- substr(colnames(countdata),start=1,stop=7)
head(countdata)
```

```{r DGEList}
dglist <- DGEList(countdata)
# have a look at y
dglist
names(dglist)

group <- paste(sampleinfo$CellType,sampleinfo$Status,sep=".")
# Take a look
group <- factor(group)
group

dglist$samples$group <- group
dglist$samples
```

```{r Annotations}
columns(org.Mm.eg.db)
ann <- select(org.Mm.eg.db,keys=rownames(dglist$counts),columns=c("ENTREZID","SYMBOL","GENENAME"))
table(ann$ENTREZID==rownames(dglist$counts))
dglist$genes <- ann
```

```{r Filtering Out Genes}
# Obtain CPMs
myCPM <- cpm(countdata)

# Have a look at the output
head(myCPM)

# Which values in myCPM are greater than 0.5?
thresh <- myCPM > 0.5

# This produces a logical matrix with TRUEs and FALSEs
head(thresh)

# Summary of how many TRUEs there are in each row
# There are 11433 genes that have TRUEs in all 12 samples.
table(rowSums(thresh))

# we would like to keep genes that have at least 2 TRUES in each row of thresh
keep <- rowSums(thresh) >= 2
summary(keep)

# Let's have a look and see whether our threshold of 0.5 does indeed correspond to a count of about 10-15
# We will look at the first sample
plot(myCPM[,1],countdata[,1])

# Let us limit the x and y-axis so we can actually look to see what is happening at the smaller counts
plot(myCPM[,1],countdata[,1],ylim=c(0,50),xlim=c(0,3))
# Add a vertical line at 0.5 CPM
abline(v=0.5)

dglist <- dglist[keep, keep.lib.sizes=FALSE]
```

```{r Quality Control}
dglist$samples$lib.size

# The names argument tells the barplot to use the sample names on the x-axis
# The las argument rotates the axis names

barplot(dglist$samples$lib.size/1e06, names=colnames(dglist), las=2, ann=FALSE, cex.names=0.75)
mtext(side = 1, text = "Samples", line = 4)
mtext(side = 2, text = "Library size (millions)", line = 3)
title("Barplot of library sizes")

# Get log2 counts per million
logcounts <- cpm(dglist,log=TRUE)
# Check distributions of samples using boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2)
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
```















#-----------------------------------Testing area---------------------------
```{r TEST}
library(MASS)
gaussprocess <- function(from = 0, to = 1, K = function(s, t) {min(s, t)},
                         start = 0, m = 1000) {
  # Simulates a Gaussian process with a given kernel
  #
  # args:
  #   from: numeric for the starting location of the sequence
  #   to: numeric for the ending location of the sequence
  #   K: a function that corresponds to the kernel (covariance function) of
  #      the process; must give numeric outputs, and if this won't produce a
  #      positive semi-definite matrix, it could fail; default is a Wiener
  #      process
  #   start: numeric for the starting position of the process
  #   m: positive integer for the number of points in the process to simulate
  #
  # return:
  #   A data.frame with variables "t" for the time index and "xt" for the value
  #   of the process

  t <- seq(from = from, to = to, length.out = m)
  Sigma <- sapply(t, function(s1) {
    sapply(t, function(s2) {
      K(s1, s2)
    })
  })

  path <- mvrnorm(mu = rep(0, times = m), Sigma = Sigma)
  path <- path - path[1] + start  # Must always start at "start"

  return(data.frame("t" = t, "xt" = path))
}
```
```{r Gaus}

head(df)
for(x in 1:5){
  df <- as.data.frame(gaussprocess())
  plot(df)
}

#ggplot(df)

```

```{r something}
# TK
```


## References


https://combine-australia.github.io/RNAseq-R/06-rnaseq-day1.html
https://www.r-bloggers.com/2012/04/gaussian-process-regression-with-r/
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4827276/